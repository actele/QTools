// ==UserScript==
// @name         QTools - Cookie & Network Capture Tool
// @namespace    https://github.com/actele/QTools
// @version      2.3.0
// @description  Á®≥ÂÆöÊäìÂèñ fetch/XHR/sendBeacon/SSE/WebSocketÔºõÂè™Âú®È°∂Â±ÇÁ™óÂè£ÊòæÁ§∫ÊåâÈíÆÔºõwatchdog Èò≤Ë¶ÜÁõñÔºõËÆæÁΩÆÈáåÂèØÂàáÊç¢ÂºÄÂÖ≥/ÂÖ®Èáè/ÂêåÊ∫ê/ËøáÊª§Ê≠£Âàô & CookieÂõûÊòæÁ´ØÁÇπÔºõCookieÂêàÂπ∂Â§öPath(ÈùûHttpOnly) + ‰∏ÄÈîÆÊäìÂÖ®(Âê´HttpOnly,ÈúÄÁ´ØÁÇπ)ÔºõÁΩëÁªúÈù¢ÊùøÊîØÊåÅÂÆûÊó∂Á≠õÈÄâ‰∏éÂØºÂá∫HARÔºõAlt+N ÁΩëÁªúÈù¢ÊùøÔºõAlt+Shift+G ÂºÄ/ÂÖ≥Êú¨ÂüüÊäìÂèñÔºà‰ªÖËá™Êµã/ÂêàÊ≥ïÁî®ÈÄîÔºâ
// @author       actele
// @match        *://*/*
// @run-at       document-start
// @inject-into  page
// @grant        GM_addStyle
// @grant        GM_setClipboard
// @grant        GM_getValue
// @grant        GM_setValue
// ==/UserScript==

(function () {
  'use strict';

  /** ===== ÈªòËÆ§ÈÖçÁΩÆ ===== */
  const BTN_TEXT = 'üç™ QTools';
  const BTN_INIT_POS = { right: 16, bottom: 16 };
  const SHOW_TOAST = true;

  const DEFAULT_ON  = false;   // ÂàùÊ¨°ÈªòËÆ§ÂÖ≥Èó≠Êú¨ÂüüÊäìÂèñ
  const DEFAULT_ALL = false;   // ÈªòËÆ§ÊåâËøáÊª§
  const DEFAULT_SAME = true;   // ÈªòËÆ§‰ªÖÂêåÊ∫ê
  const DEFAULT_FILTER_REGEX = String(/(\/api\/|\/prod-api\/|\/graphql|\/v[0-9]+\/|\/ajax\/)/i);
  const DEFAULT_COOKIE_ECHO_ENDPOINT = ''; // ‰æã: /__echo_cookie__ ÔºàÂêåÊ∫ê‰ºòÂÖàÔºâ

  // ÊäìÂèñÁªÜËäÇ
  const CAPTURE_REQ_HEADERS = true;
  const CAPTURE_RES_HEADERS = true;
  const CAPTURE_REQ_BODY   = true;
  const CAPTURE_RES_BODY   = true;
  const CAPTURE_SEND_BEACON = true;
  const CAPTURE_SSE = true;
  const CAPTURE_WEBSOCKET = true;

  const MAX_BODY_KB = 128;
  const MAX_LOGS = 1000;

  // ÈªëÂêçÂçïÂüüÔºàÂº∫Âà∂ÂÖ≥Èó≠Ôºâ
  const DOMAIN_BLACKLIST = [
    /(?:^|\.)alipay\.com$/i,
    /(?:^|\.)paypal\.com$/i,
    /(?:^|\.)stripe\.com$/i,
    /(bank|icbc|ccb|abc|cmb|citic|spdb|ceb|psbc)/i,
  ];
  /** ==================== */

  const ORIGIN = location.origin;
  const STORE_KEY = '__qtools_site_prefs__';

  function loadAllPrefs(){ try { return JSON.parse(GM_getValue(STORE_KEY, '{}')); } catch { return {}; } }
  function saveAllPrefs(p){ GM_setValue(STORE_KEY, JSON.stringify(p || {})); }
  function isBlacklistedHost(){ return DOMAIN_BLACKLIST.some(re => { try { return re.test(location.hostname); } catch { return false; } }); }

  function getState() {
    const all = loadAllPrefs();
    const per = all[ORIGIN] || {};
    const black = isBlacklistedHost();
    if (black) return { on:false, all:false, same:true, filter: DEFAULT_FILTER_REGEX, echo: '', black:true };
    return {
      on    : typeof per.on    === 'boolean' ? per.on    : DEFAULT_ON,
      all   : typeof per.all   === 'boolean' ? per.all   : DEFAULT_ALL,
      same  : typeof per.same  === 'boolean' ? per.same  : DEFAULT_SAME,
      filter: typeof per.filter=== 'string'  ? per.filter: DEFAULT_FILTER_REGEX,
      echo  : typeof per.echo  === 'string'  ? per.echo  : DEFAULT_COOKIE_ECHO_ENDPOINT,
      black : false,
    };
  }
  function setState(patch){
    const all = loadAllPrefs();
    const per = all[ORIGIN] || {};
    all[ORIGIN] = { ...per, ...patch };
    saveAllPrefs(all);
    if (isTopWindow()) updateBadge();
  }

  function isTopWindow(){ try { return window.top === window; } catch { return true; } }

  // ===== Â∑•ÂÖ∑ =====
  const NETLOGS = [];
  const clamp = () => { while (NETLOGS.length > MAX_LOGS) NETLOGS.shift(); };
  function toast(msg, ttl=1500){ if(!SHOW_TOAST) return; const t=document.createElement('div'); t.className='qtools-toast'; t.textContent=msg; document.documentElement.appendChild(t); setTimeout(()=>t.remove(), ttl); }
  function copy(t){ if(typeof GM_setClipboard==='function'){ GM_setClipboard(t,{type:'text'}); return Promise.resolve(); } if(navigator.clipboard?.writeText) return navigator.clipboard.writeText(t); const ta=document.createElement('textarea'); ta.value=t; document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove(); return Promise.resolve(); }
  function parseCookie(s){ const o={}; (s||'').split(';').forEach(p=>{ const i=p.indexOf('='); if(i===-1) return; const k=decodeURIComponent(p.slice(0,i).trim()); let v=p.slice(i+1).trim(); try{ v=decodeURIComponent(v) }catch{} o[k]=v; }); return o; }
  function toHeader(obj){ return Object.entries(obj).map(([k,v])=>`${k}=${v}`).join('; '); }
  function kbLimit(str){ if(typeof str!=='string') return str; const max=MAX_BODY_KB*1024; if(new TextEncoder().encode(str).length>max) return str.slice(0,max)+`\n/* truncated at ${MAX_BODY_KB}KB */`; return str; }
  function compileRegex(str){ try{ const m=String(str||'').trim(); if(/^\/.*\/[a-z]*$/i.test(m)){ const body=m.replace(/^\/(.*)\/[a-z]*$/i,'$1'); const flags=m.replace(/^\/.*\/([a-z]*)$/i,'$1'); return new RegExp(body,flags); } const esc=m.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); return new RegExp(esc,'i'); }catch{ return /(\/api\/|\/prod-api\/|\/graphql|\/v[0-9]+\/|\/ajax\/)/i; } }
  function isSameOrigin(u){ try{ return new URL(u, location.href).origin === location.origin; }catch{ return false; } }
  function shouldKeep(entry){
    const st=getState();
    if(!st.on || st.black) return false;
    if(!entry?.url) return false;
    if(!st.all){
      if(st.same && !isSameOrigin(entry.url)) return false;
      const re=compileRegex(st.filter);
      try{ if(!re.test(String(entry.url))) return false; }catch{ return false; }
    }
    return true;
  }

  // ===== Cookie Store APIÔºöÂ∞ΩÈáèÂêàÂπ∂Â§ö Path ÁöÑÂèØËØª CookieÔºàÈùû HttpOnlyÔºâ=====
  async function readAllVisibleCookies() {
    const base = parseCookie(document.cookie || '');
    if (!('cookieStore' in navigator) || typeof navigator.cookieStore.getAll !== 'function') {
      return base;
    }
    const prefixPaths = [];
    const segs = (location.pathname || '/').split('/').filter(Boolean);
    let cur = '';
    for (let i = 0; i < segs.length; i++) { cur += '/' + segs[i]; prefixPaths.push(cur); }
    const candidates = new Set(['/', ...prefixPaths, '/admin', '/api', '/app', '/login', '/static']
      .map(p => new URL(p, location.origin).toString()));
    const merged = { ...base };
    try {
      for (const url of candidates) {
        const list = await navigator.cookieStore.getAll({ url });
        for (const c of list) { if (!(c.name in merged)) merged[c.name] = c.value; }
      }
    } catch (e) { console.debug('[QTools] cookieStore.getAll fallback:', e); }
    return merged;
  }

  // ===== Ê†∑Âºè =====
  GM_addStyle(`
    .qtools-fab{position:fixed;right:${BTN_INIT_POS.right}px;bottom:${BTN_INIT_POS.bottom}px;z-index:2147483647;
      padding:10px 14px;border-radius:999px;box-shadow:0 6px 18px rgba(0,0,0,.2);background:#111;color:#fff;
      font-size:14px;cursor:grab;opacity:.92;display:inline-flex;align-items:center;gap:8px;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans SC","PingFang SC","Microsoft YaHei",sans-serif;}
    .qtools-fab:active{cursor:grabbing;}
    .qtools-fab-badge{position:absolute;right:-6px;top:-6px;background:#16a34a;color:#fff;border-radius:10px;padding:2px 6px;font-size:10px;line-height:1;}
    .qtools-fab-badge.off{background:#6b7280;}
    .qtools-toast{position:fixed;left:50%;transform:translateX(-50%);bottom:72px;background:#111;color:#fff;
      padding:8px 12px;border-radius:8px;font-size:12px;box-shadow:0 6px 18px rgba(0,0,0,.2);z-index:2147483647;opacity:.95;}
    .qtools-panel-mask{position:fixed;inset:0;z-index:2147483647;background:rgba(0,0,0,.35);display:flex;align-items:center;justify-content:center;}
    .qtools-panel{width:min(1000px,94vw);max-height:86vh;overflow:auto;background:#fff;border-radius:12px;
      padding:16px 16px 12px;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Arial,"Noto Sans SC","PingFang SC","Microsoft YaHei",sans-serif;color:#111;box-shadow:0 10px 32px rgba(0,0,0,.25);}
    .qtools-panel pre{white-space:pre-wrap;word-break:break-all;border:1px solid #eee;border-radius:8px;padding:10px;margin:0;background:#fafafa;}
    .qtools-btn{padding:6px 10px;border-radius:8px;border:1px solid #eaeaea;background:#f7f7f7;cursor:pointer;}
    .qtools-btn:hover{background:#efefef;}
    .qtools-head{display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:10px;}
    .qtools-actions{display:flex;gap:8px;flex-wrap:wrap;}
    .qtools-table{width:100%;border-collapse:collapse;font-size:13px;}
    .qtools-table th,.qtools-table td{padding:6px 8px;border-bottom:1px solid #eee;vertical-align:top;text-align:left;}
    .qtools-badge{display:inline-block;padding:2px 6px;border-radius:6px;background:#f0f0f0;font-size:12px;}
    .qtools-link{color:#1677ff;cursor:pointer;text-decoration:underline;}
    .qtools-nowrap{white-space:nowrap;}
    .qtools-row{display:flex;align-items:center;gap:8px;margin:6px 0;flex-wrap:wrap;}
    .qtools-row label{display:flex;align-items:center;gap:6px;}
    .qtools-input{padding:6px 8px;border:1px solid #e5e7eb;border-radius:8px;min-width:320px;}
    .qtools-filter{flex:1; min-width:240px;}
    .qtools-hint{color:#666;font-size:12px;}
  `);

  // ===== ‰ªÖÈ°∂Â±ÇÁ™óÂè£ÊòæÁ§∫ÊåâÈíÆÔºàÈò≤ÈáçÂ§çÔºâ =====
  const FAB_ID = 'qtools-fab';
  function mountFabOnce(){
    if(!isTopWindow()) return;
    if(window.__QTOOLS_FAB_EXIST__) return;
    if(document.getElementById(FAB_ID)) return;
    window.__QTOOLS_FAB_EXIST__ = true;

    const btn = document.createElement('div');
    btn.id = FAB_ID;
    btn.className = 'qtools-fab';
    btn.innerHTML = `<span>${BTN_TEXT}</span>`;
    btn.title = 'ÁÇπÂáªÊü•Áúã Cookie/UAÔºõAlt+N ÁΩëÁªúÈù¢ÊùøÔºõAlt+Shift+G ÂºÄ/ÂÖ≥Êú¨ÂüüÊäìÂèñ';

    const badge = document.createElement('div');
    badge.className = 'qtools-fab-badge off';
    badge.textContent = 'OFF';
    btn.appendChild(badge);

    function updateBadge(){
      const st = getState();
      badge.textContent = st.on ? 'ON' : 'OFF';
      badge.classList.toggle('off', !st.on);
    }
    updateBadge();
    window.__QTOOLS_UPDATE_BADGE__ = updateBadge; // Â§ñÈÉ®Âà∑Êñ∞

    // ËÆ∞ÂøÜ‰ΩçÁΩÆ
    const POS_KEY='__qtools_fab_pos__';
    try{
      const s=JSON.parse(localStorage.getItem(POS_KEY)||'{}');
      if(typeof s.right==='number') btn.style.right=s.right+'px';
      if(typeof s.bottom==='number') btn.style.bottom=s.bottom+'px';
    }catch{}
    const savePos=()=>{ const r=parseInt(btn.style.right,10)||BTN_INIT_POS.right; const b=parseInt(btn.style.bottom,10)||BTN_INIT_POS.bottom; localStorage.setItem(POS_KEY, JSON.stringify({right:r,bottom:b})); };
    (function(){ let sx=0,sy=0,sr=0,sb=0,drag=false;
      const dn=(x,y)=>{ drag=true; btn.style.transition='none'; btn.style.cursor='grabbing';
        sx=x; sy=y; const rect=btn.getBoundingClientRect(); sr=innerWidth-rect.right; sb=innerHeight-rect.bottom; };
      const mv=(x,y)=>{ if(!drag) return; btn.style.right=Math.max(4, sr-(x-sx))+'px'; btn.style.bottom=Math.max(4, sb-(y-sy))+'px'; };
      const up=()=>{ if(!drag) return; drag=false; btn.style.cursor='grab'; btn.style.transition=''; savePos(); };
      btn.addEventListener('mousedown',e=>{ dn(e.clientX,e.clientY); e.preventDefault(); });
      addEventListener('mousemove',e=>mv(e.clientX,e.clientY));
      addEventListener('mouseup',up);
      btn.addEventListener('touchstart',e=>{ const t=e.touches[0]; dn(t.clientX,t.clientY); },{passive:true});
      addEventListener('touchmove',e=>{ const t=e.touches[0]; mv(t.clientX,t.clientY); },{passive:true});
      addEventListener('touchend',up);
    })();

    // ÊâìÂºÄ Cookie/UA Èù¢ÊùøÔºàÂºÇÊ≠•ÂêàÂπ∂ÂèØËØª CookieÔºâ
    btn.addEventListener('click', async ()=> { const parsed=await readAllVisibleCookies(); openCookiePanel(parsed); });

    // ÂÆâË£Ö‰∏é‰øùÊ¥ª
    const ensure=()=>{ if(!document.getElementById(FAB_ID)) document.documentElement.appendChild(btn); };
    new MutationObserver(ensure).observe(document.documentElement,{childList:true,subtree:true}); ensure();

    // Âø´Êç∑ÈîÆÔºàÈ°∂Â±ÇÔºâ
    addEventListener('keydown', (e) => {
      if (e.altKey && !e.shiftKey && e.code === 'KeyN') { openNetPanel(); }
      if (e.altKey && e.shiftKey && e.code === 'KeyG') {
        const st = getState();
        if (st.black) { toast('ËØ•ÂüüÂú®ÈªëÂêçÂçïÔºåÂ∑≤Âº∫Âà∂ÂÖ≥Èó≠'); return; }
        setState({ on: !st.on });
        toast(`Êú¨ÂüüÊäìÂèñÔºö${!st.on ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠'}`);
        updateBadge();
      }
    }, { capture: true });
  }
  function updateBadge(){ try{ window.__QTOOLS_UPDATE_BADGE__ && window.__QTOOLS_UPDATE_BADGE__(); }catch{} }

  // ===== ÈÄöÁî®ÂºπÁ™óÂ∑•ÂÖ∑ÔºöÊ≠¶Ë£ÖÂª∂Ëøü + ÂÜÖÈÉ®ÈòªÊñ≠ =====
  function armMask(mask){ mask.dataset.armed='0'; requestAnimationFrame(()=>{ mask.dataset.armed='1'; }); }
  function makeMaskClose(mask, panel){
    panel.addEventListener('click', e=>e.stopPropagation());
    mask.addEventListener('click', (e)=>{ if(e.target!==mask) return; if(mask.dataset.armed!=='1'){ e.preventDefault(); return; } mask.remove(); });
  }

  // ===== Cookie ÂõûÊòæÁ´ØÁÇπ =====
  async function fetchEchoCookie(endpoint){
    if(!endpoint){ toast('ËØ∑ÂÖàÂú®ËÆæÁΩÆÈáåÈÖçÁΩÆ"Cookie ÂõûÊòæÁ´ØÁÇπ"'); throw new Error('no endpoint');}
    const res = await fetch(endpoint, { method:'GET', credentials:'include' });
    const text = await res.text();
    try{
      const j = JSON.parse(text);
      const val = j.cookieHeader || j.cookie || j.headers?.cookie || '';
      return String(val||'').trim() || text.trim();
    }catch{
      return text.trim();
    }
  }

  // ===== Cookie/UA Èù¢Êùø =====
  function openCookiePanel(obj){
    const mask=document.createElement('div'); mask.className='qtools-panel-mask'; armMask(mask);
    const panel=document.createElement('div'); panel.className='qtools-panel'; makeMaskClose(mask,panel);

    const jsonStr=JSON.stringify(obj,null,2);
    const headerStr=toHeader(obj);
    const uaStr=navigator.userAgent;
    const st=getState();

    panel.innerHTML = `
      <div class="qtools-head">
        <strong>Cookie È¢ÑËßàÔºà‰ªÖÈùû HttpOnlyÔºåÂèØËØª ${Object.keys(obj).length} Êù°Ôºâ</strong>
        <div class="qtools-actions">
          <button class="qtools-btn" id="cph">Â§çÂà∂ Header</button>
          <button class="qtools-btn" id="cpj">Â§çÂà∂ JSON</button>
          <button class="qtools-btn" id="cpu">Â§çÂà∂ UA</button>
          <button class="qtools-btn" id="full">ÊäìÂÖ® CookieÔºàÈúÄÁ´ØÁÇπÔºâ</button>
          <button class="qtools-btn" id="opn">ÁΩëÁªúËØ∑Ê±Ç</button>
          <button class="qtools-btn" id="cfg">ËÆæÁΩÆ</button>
          <button class="qtools-btn" id="cls">ÂÖ≥Èó≠</button>
        </div>
      </div>
      <pre>${Object.entries(obj).map(([k,v])=>`${k} = ${v}`).join('\n') || '(Êó†ÂèØËØª Cookie)'}</pre>
      <pre style="margin-top:10px;">User-Agent: ${uaStr}</pre>
      <div class="qtools-hint" style="margin-top:8px;">
        * ÊµèËßàÂô® JS ËØª‰∏çÂà∞ HttpOnlyÔºõ"ÊäìÂÖ® Cookie"ÈúÄÂõûÊòæÁ´ØÁÇπ„ÄÇ<br/>
        * ÂΩìÂâçÁ´ôÁÇπÔºö${st.on ? 'ÊäìÂèñÂºÄÂêØ' : 'ÊäìÂèñÂÖ≥Èó≠'}Ôºõ‰ªÖÂêåÊ∫êÔºö${st.same ? 'ÊòØ' : 'Âê¶'}ÔºõÊ®°ÂºèÔºö${st.all ? 'ÂÖ®Èáè' : 'ÊåâËøáÊª§'}ÔºõËøáÊª§Ôºö${st.filter}ÔºõÂõûÊòæÁ´ØÁÇπÔºö${st.echo||'(Êú™ÈÖçÁΩÆ)'}
      </div>
    `;
    mask.appendChild(panel); document.documentElement.appendChild(mask);

    panel.querySelector('#cls').addEventListener('click',(e)=>{ e.stopPropagation(); mask.remove(); });
    panel.querySelector('#cph').addEventListener('click',async(e)=>{ e.stopPropagation(); await copy(headerStr); toast('Â∑≤Â§çÂà∂ Header'); });
    panel.querySelector('#cpj').addEventListener('click',async(e)=>{ e.stopPropagation(); await copy(jsonStr); toast('Â∑≤Â§çÂà∂ JSON'); });
    panel.querySelector('#cpu').addEventListener('click',async(e)=>{ e.stopPropagation(); await copy(uaStr); toast('Â∑≤Â§çÂà∂ UA'); });
    panel.querySelector('#opn').addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); mask.remove(); setTimeout(()=>openNetPanel(),0); });
    panel.querySelector('#cfg').addEventListener('click',(e)=>{ e.preventDefault(); e.stopPropagation(); mask.remove(); setTimeout(()=>openSettingsPanel(),0); });
    panel.querySelector('#full').addEventListener('click', async (e)=>{
      e.preventDefault(); e.stopPropagation();
      try{
        const raw = await fetchEchoCookie(getState().echo);
        if(!raw){ toast('Á´ØÁÇπËøîÂõû‰∏∫Á©∫'); return; }
        const mm=document.createElement('div'); mm.className='qtools-panel-mask'; armMask(mm);
        const pp=document.createElement('div'); pp.className='qtools-panel'; makeMaskClose(mm,pp);
        pp.innerHTML = `
          <div class="qtools-head">
            <strong>ÂÆåÊï¥ CookieÔºàÂåÖÂê´ HttpOnlyÔºåÊù•Ëá™ÊúçÂä°Á´ØÂõûÊòæÔºâ</strong>
            <div class="qtools-actions">
              <button class="qtools-btn" id="cp">Â§çÂà∂</button>
              <button class="qtools-btn" id="close">ÂÖ≥Èó≠</button>
            </div>
          </div>
          <pre>${raw}</pre>
          <div class="qtools-hint">ËøôÊòØ"ËØ∑Ê±ÇÂ§¥ Cookie"ÂéüÊñáÔºõÂèØÁõ¥Êé•Á≤òË¥¥Âà∞Â∑•ÂÖ∑Êàñ cURL„ÄÇ</div>
        `;
        mm.appendChild(pp); document.documentElement.appendChild(mm);
        pp.querySelector('#cp').addEventListener('click', async (x)=>{ x.stopPropagation(); await copy(raw); toast('Â∑≤Â§çÂà∂'); });
        pp.querySelector('#close').addEventListener('click', (x)=>{ x.stopPropagation(); mm.remove(); });
      }catch(err){ console.error(err); toast('ÊäìÂÖ®Â§±Ë¥•ÔºöÁ´ØÁÇπÊó†ÂìçÂ∫îÊàñË∑®ÂüüÂèóÈôê'); }
    });
  }

  // ===== ËÆæÁΩÆÈù¢Êùø =====
  function openSettingsPanel(){
    const st=getState();
    const mask=document.createElement('div'); mask.className='qtools-panel-mask'; armMask(mask);
    const panel=document.createElement('div'); panel.className='qtools-panel'; makeMaskClose(mask,panel);

    panel.innerHTML = `
      <div class="qtools-head">
        <strong>ÊäìÂèñËÆæÁΩÆÔºà‰ªÖÂΩìÂâçÁ´ôÁÇπÔºâ</strong>
        <div class="qtools-actions">
          <button class="qtools-btn" id="save">‰øùÂ≠ò</button>
          <button class="qtools-btn" id="cls">ÂÖ≥Èó≠</button>
        </div>
      </div>
      <div class="qtools-row">
        <label><input type="checkbox" id="on"   ${st.on?'checked':''}/> ÂºÄÂêØÊäìÂèñÔºàON/OFFÔºâ</label>
        <label><input type="checkbox" id="all"  ${st.all?'checked':''}/> ÂÖ®ÈáèÊäìÂèñÔºàÂøΩÁï•ËøáÊª§Ôºâ</label>
        <label><input type="checkbox" id="same" ${st.same?'checked':''}/> ‰ªÖÂêåÊ∫ê</label>
      </div>
      <div class="qtools-row">
        <div>ËøáÊª§Ê≠£ÂàôÔºö</div>
        <input class="qtools-input" id="re" value="${String(st.filter).replace(/"/g,'&quot;')}"/>
        <button class="qtools-btn" id="test">ÊµãËØï</button>
      </div>
      <div class="qtools-row">
        <div>Cookie ÂõûÊòæÁ´ØÁÇπÔºö</div>
        <input class="qtools-input" id="echo" placeholder="/__echo_cookie__" value="${String(st.echo||'').replace(/"/g,'&quot;')}"/>
      </div>
      <div class="qtools-hint">
        * Á´ØÁÇπÈúÄËøîÂõû"ËØ∑Ê±ÇÂ§¥ Cookie"ÔºõÂèØËøîÂõû JSON: {"cookieHeader":"..."} ÊàñÁ∫ØÊñáÊú¨„ÄÇÂª∫ËÆÆÂêåÊ∫êÈÉ®ÁΩ≤„ÄÇ<br/>
        * ËøáÊª§Ê≠£ÂàôÂèØÁî® /.../iÔºåÊàñÁõ¥Êé•ÂÖ≥ÈîÆÂ≠óÔºàÊåâÂåÖÂê´ÂåπÈÖçÔºâ„ÄÇ
      </div>
    `;
    mask.appendChild(panel); document.documentElement.appendChild(mask);

    panel.querySelector('#cls').addEventListener('click',(e)=>{ e.stopPropagation(); mask.remove(); });
    panel.querySelector('#test').addEventListener('click',(e)=>{ e.stopPropagation(); try{ const re=compileRegex(panel.querySelector('#re').value.trim()); toast(`Ê≠£ÂàôÂèØÁî®Ôºö${re}`);}catch{ toast('Ê≠£ÂàôÊó†Êïà'); } });
    panel.querySelector('#save').addEventListener('click',(e)=>{
      e.stopPropagation();
      const on   = panel.querySelector('#on').checked;
      const all  = panel.querySelector('#all').checked;
      const same = panel.querySelector('#same').checked;
      const reStr= panel.querySelector('#re').value.trim() || DEFAULT_FILTER_REGEX;
      const echo = panel.querySelector('#echo').value.trim();
      setState({ on, all, same, filter: reStr, echo });
      toast('Â∑≤‰øùÂ≠òËÆæÁΩÆ'); mask.remove(); updateBadge();
    });
  }

  // ===== HAR ÂØºÂá∫ =====
  function toHarHeaders(obj) {
    if (!obj) return [];
    return Object.entries(obj).map(([name, value]) => ({ name: String(name), value: String(value) }));
  }
  function toQueryString(url) {
    try {
      const u = new URL(url, location.href);
      return Array.from(u.searchParams.entries()).map(([name, value]) => ({ name, value }));
    } catch { return []; }
  }
  function buildHar() {
    const started = new Date();
    const log = {
      log: {
        version: '1.2',
        creator: { name: 'QTools', version: '2.3.0' },
        pages: [{
          startedDateTime: started.toISOString(),
          id: 'page_1',
          title: document.title || location.href,
          pageTimings: { onContentLoad: -1, onLoad: -1 }
        }],
        entries: NETLOGS.map((x) => {
          const startedDateTime = new Date(x.startTime || Date.now()).toISOString();
          const time = Number.isFinite(x.duration) ? x.duration : 0;
          const reqHeaders = toHarHeaders(x.request?.headers);
          const resHeaders = toHarHeaders(x.response?.headers);
          const postData = x.request?.body == null ? undefined : {
            mimeType: typeof x.request.body === 'string' ? 'text/plain' : 'application/json',
            text: typeof x.request.body === 'string' ? String(x.request.body) : JSON.stringify(x.request.body, null, 2)
          };
          const content = x.response?.body == null ? { size: -1, mimeType: resHeaders.find(h=>h.name.toLowerCase()==='content-type')?.value || '' }
            : { size: -1, mimeType: resHeaders.find(h=>h.name.toLowerCase()==='content-type')?.value || 'text/plain', text: typeof x.response.body === 'string' ? String(x.response.body) : JSON.stringify(x.response.body, null, 2) };
          return {
            pageref: 'page_1',
            startedDateTime,
            time,
            request: {
              method: x.method || 'GET',
              url: x.url || '',
              httpVersion: 'HTTP/1.1',
              headers: reqHeaders,
              queryString: toQueryString(x.url || ''),
              headersSize: -1,
              bodySize: -1,
              postData
            },
            response: {
              status: Number.isFinite(x.status) ? x.status : 0,
              statusText: '',
              httpVersion: 'HTTP/1.1',
              headers: resHeaders,
              cookies: [],
              content,
              redirectURL: '',
              headersSize: -1,
              bodySize: -1
            },
            cache: {},
            timings: { send: 0, wait: time, receive: 0 }
          };
        })
      }
    };
    return log;
  }
  function downloadHar() {
    const har = buildHar();
    const blob = new Blob([JSON.stringify(har, null, 2)], { type: 'application/json' });
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    const a = document.createElement('a');
    a.download = `qtools-${location.hostname}-${ts}.har`;
    a.href = URL.createObjectURL(blob);
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);
    toast('Â∑≤ÂØºÂá∫ HAR');
  }

  // ===== ÁΩëÁªúÈù¢ÊùøÔºàÂÆûÊó∂Á≠õÈÄâ + ÂØºÂá∫HARÔºâ =====
  function rowHTML(x, i) {
    const color = x.status >= 200 && x.status < 400 ? '#52c41a' : (x.status ? '#faad14' : '#ff4d4f');
    return `<tr>
      <td class="qtools-nowrap"><span class="qtools-badge" title="${new Date(x.startTime).toLocaleString()}">${x.method}</span></td>
      <td style="max-width:580px;word-break:break-all;"><div>${x.url}</div><div style="color:#666;font-size:12px;">${x.status ?? '-'} ‚Ä¢ ${x.duration ?? '-'}ms</div></td>
      <td class="qtools-nowrap"><span style="color:${color}">${x.status ?? '-'}</span></td>
      <td class="qtools-nowrap">${x.duration ?? '-'}ms</td>
      <td class="qtools-nowrap"><span class="qtools-link" data-i="${i}" data-act="detail">ËØ¶ÊÉÖ</span></td>
    </tr>`;
  }
  function openNetDetail(x){
    const mask=document.createElement('div'); mask.className='qtools-panel-mask'; armMask(mask);
    const panel=document.createElement('div'); panel.className='qtools-panel'; makeMaskClose(mask,panel);
    const reqH=x.request?.headers?JSON.stringify(x.request.headers,null,2):'{}';
    const resH=x.response?.headers?JSON.stringify(x.response.headers,null,2):'{}';
    const reqB=x.request?.body??''; const resB=x.response?.body??'';
    panel.innerHTML = `
      <div class="qtools-head">
        <strong>${x.method} ${x.status ?? '-'} ‚Ä¢ ${x.duration ?? '-'}ms</strong>
        <div class="qtools-actions">
          <button class="qtools-btn" id="copy">Â§çÂà∂ÂÖ®ÈÉ®JSON</button>
          <button class="qtools-btn" id="cls">ÂÖ≥Èó≠</button>
        </div>
      </div>
      <div style="margin-bottom:6px;word-break:break-all;"><b>URL:</b> ${x.url}</div>
      <pre><b>Request Headers</b>\n${reqH}</pre>
      ${reqB ? `<pre style="margin-top:8px;"><b>Request Body</b>\n${typeof reqB==='string'?reqB:JSON.stringify(reqB,null,2)}</pre>`:''}
      <pre style="margin-top:8px;"><b>Response Headers</b>\n${resH}</pre>
      ${resB ? `<pre style="margin-top:8px;"><b>Response Body</b>\n${typeof resB==='string'?resB:JSON.stringify(resB,null,2)}</pre>`:''}
    `;
    mask.appendChild(panel); document.documentElement.appendChild(mask);
    panel.querySelector('#copy').addEventListener('click', async (e)=>{ e.stopPropagation(); await copy(JSON.stringify(x,null,2)); toast('Â∑≤Â§çÂà∂'); });
    panel.querySelector('#cls').addEventListener('click', (e)=>{ e.stopPropagation(); mask.remove(); });
  }

  function openNetPanel(){
    const mask=document.createElement('div'); mask.className='qtools-panel-mask'; armMask(mask);
    const panel=document.createElement('div'); panel.className='qtools-panel'; makeMaskClose(mask,panel);
    const st=getState();

    // ËøáÊª§Áä∂ÊÄÅ
    let filterStr = '';
    let filterIsRegex = false;
    let live = true;

    // Ê∏≤ÊüìÂáΩÊï∞ÔºàÊåâËøáÊª§‰∏éÊúÄÊñ∞Êï∞ÊçÆÔºâ
    function filteredLogs() {
      if (!filterStr) return NETLOGS;
      try {
        if (filterIsRegex) {
          const re = new RegExp(filterStr, 'i');
          return NETLOGS.filter(x => re.test(x.url) || re.test(x.method) || re.test(String(x.status)));
        } else {
          const s = filterStr.toLowerCase();
          return NETLOGS.filter(x => (x.url||'').toLowerCase().includes(s) ||
                                     (x.method||'').toLowerCase().includes(s) ||
                                     String(x.status||'').toLowerCase().includes(s));
        }
      } catch { return NETLOGS; }
    }
    function renderTable() {
      const rows = filteredLogs().map((x, i) => rowHTML(x, i)).reverse().join('');
      const tb = panel.querySelector('#tb');
      tb.innerHTML = rows || `<tr><td colspan="5" style="color:#666;">ÊöÇÊó†ËÆ∞ÂΩïÔºàAlt+N ÊâìÂºÄÔºõËÆæÁΩÆÈáåÂèØÂàáÊç¢ÂºÄÂÖ≥/ÂÖ®Èáè/ÂêåÊ∫ê/ËøáÊª§Ôºâ</td></tr>`;
      // ÁªëÂÆöËØ¶ÊÉÖ
      tb.querySelectorAll('[data-act="detail"]').forEach(el => {
        el.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = Number(el.getAttribute('data-i'));
          const item = filteredLogs()[filteredLogs().length - 1 - idx]; // Âõ† reverse ÊòæÁ§∫ÔºåËÆ°ÁÆóÂõûÂéüÁ¥¢Âºï
          openNetDetail(item || NETLOGS[idx]);
        });
      });
    }

    panel.innerHTML = `
      <div class="qtools-head">
        <strong>ÁΩëÁªúËØ∑Ê±ÇÔºà${st.on ? (st.all ? 'ÂÖ®ÈáèÊäìÂèñ' : 'ÊåâËøáÊª§') : 'Â∑≤ÂÖ≥Èó≠'}ÔºõÂÖ± <span id="cnt">${NETLOGS.length}</span> Êù°Ôºâ</strong>
        <div class="qtools-actions">
          <input class="qtools-input qtools-filter" id="kw" placeholder="ÂÖ≥ÈîÆËØçÊàñÊ≠£ÂàôÔºàÂãæÈÄâRegexÔºâÂÆûÊó∂Á≠õÈÄâ URL/ÊñπÊ≥ï/Áä∂ÊÄÅ"/>
          <label><input type="checkbox" id="isre"/> Regex</label>
          <label><input type="checkbox" id="live" checked/> Live</label>
          <button class="qtools-btn" id="har">ÂØºÂá∫ HAR</button>
          <button class="qtools-btn" id="cp">Â§çÂà∂ÂÖ®ÈÉ®JSON</button>
          <button class="qtools-btn" id="clr">Ê∏ÖÁ©∫</button>
          <button class="qtools-btn" id="cfg">ËÆæÁΩÆ</button>
          <button class="qtools-btn" id="cls">ÂÖ≥Èó≠</button>
        </div>
      </div>
      <table class="qtools-table">
        <thead><tr><th>ÊñπÊ≥ï</th><th>URL / Áä∂ÊÄÅ</th><th>Áä∂ÊÄÅ</th><th>ËÄóÊó∂</th><th>Êìç‰Ωú</th></tr></thead>
        <tbody id="tb"></tbody>
      </table>
      <div class="qtools-hint" style="margin-top:8px;">
        Êú¨ÂüüÔºö${st.on ? 'ON' : 'OFF'}Ôºõ‰ªÖÂêåÊ∫êÔºö${st.same ? 'ÊòØ' : 'Âê¶'}ÔºõÊ®°ÂºèÔºö${st.all ? 'ÂÖ®Èáè' : 'ÊåâËøáÊª§'}ÔºõËøáÊª§Ôºö${st.filter}ÔºõÂõûÊòæÁ´ØÁÇπÔºö${st.echo||'(Êú™ÈÖçÁΩÆ)'}
      </div>
    `;
    mask.appendChild(panel); document.documentElement.appendChild(mask);

    // È¶ñÊ∏≤Êüì
    renderTable();

    // ‰∫§‰∫í
    const kw = panel.querySelector('#kw');
    const isre = panel.querySelector('#isre');
    const liveChk = panel.querySelector('#live');
    const cnt = panel.querySelector('#cnt');

    function doFilterRender(){
      filterStr = kw.value.trim();
      filterIsRegex = isre.checked;
      renderTable();
    }
    kw.addEventListener('input', doFilterRender);
    isre.addEventListener('change', doFilterRender);

    // Live Âà∑Êñ∞
    const timer = setInterval(() => {
      if (!document.body.contains(panel)) { clearInterval(timer); return; }
      if (!live) return;
      cnt.textContent = String(NETLOGS.length);
      renderTable();
    }, 800);
    liveChk.addEventListener('change', () => { live = liveChk.checked; });

    panel.querySelector('#cls').addEventListener('click',(e)=>{ e.stopPropagation(); clearInterval(timer); mask.remove(); });
    panel.querySelector('#cp').addEventListener('click', async (e)=>{ e.stopPropagation(); await copy(JSON.stringify(NETLOGS,null,2)); toast('Â∑≤Â§çÂà∂'); });
    panel.querySelector('#clr').addEventListener('click',(e)=>{ e.stopPropagation(); NETLOGS.length=0; renderTable(); toast('Â∑≤Ê∏ÖÁ©∫'); });
    panel.querySelector('#cfg').addEventListener('click',(e)=>{ e.stopPropagation(); clearInterval(timer); mask.remove(); setTimeout(()=>openSettingsPanel(),0); });
    panel.querySelector('#har').addEventListener('click',(e)=>{ e.stopPropagation(); downloadHar(); });
  }

  // ===== È°µÈù¢‰∏ä‰∏ãÊñá HookÔºàÊâÄÊúâ frame ÈÉΩÊ≥®ÂÖ•ÔºõÂè™È°∂Â±ÇÊúâ UIÔºâ =====
  const INJECT = `
    (function(){
      const CAPTURE_REQ_HEADERS=${CAPTURE_REQ_HEADERS}, CAPTURE_RES_HEADERS=${CAPTURE_RES_HEADERS},
            CAPTURE_REQ_BODY=${CAPTURE_REQ_BODY}, CAPTURE_RES_BODY=${CAPTURE_RES_BODY},
            CAPTURE_SEND_BEACON=${CAPTURE_SEND_BEACON}, CAPTURE_SSE=${CAPTURE_SSE}, CAPTURE_WEBSOCKET=${CAPTURE_WEBSOCKET},
            MAX_BODY_KB=${MAX_BODY_KB};
      const enc=new TextEncoder(); const kbLimit=(s)=>{ if(typeof s!=='string') return s; const max=MAX_BODY_KB*1024; if(enc.encode(s).length>max) return s.slice(0,max)+"\\n/* truncated at "+MAX_BODY_KB+"KB */"; return s; };
      const safeJSON=(t)=>{ try{return JSON.parse(t)}catch{return t} };
      const post=(entry)=>{ try{ window.postMessage({__QTOOLS_NET__:true, entry}, '*'); }catch{} try{ if(window.top && window.top!==window) window.top.postMessage({__QTOOLS_NET__:true, entry}, '*'); }catch{} };

      // fetch
      const origFetch=window.fetch;
      const fetchWrap=async function(input, init={}) {
        const start=performance.now();
        const url=(typeof input==='string')?input:(input?.url||'');
        const method=(init?.method||(typeof input!=='string'?input.method:'GET')||'GET').toUpperCase();
        let reqH={}, reqB;
        if(CAPTURE_REQ_HEADERS){ try{ const h=(init?.headers||(typeof input!=='string'?input.headers:null)); if(h) reqH=Object.fromEntries(new Headers(h).entries()); }catch{} }
        if(CAPTURE_REQ_BODY && init?.body!=null){
          try{ if(typeof init.body==='string') reqB=safeJSON(kbLimit(init.body));
               else if(init.body instanceof Blob) reqB="Blob("+(init.body.type||"unknown")+", "+init.body.size+" bytes)";
               else if(init.body instanceof FormData){ const o={}; for(const [k,v] of init.body.entries()) o[k]=(v instanceof File)? "File("+v.name+","+v.size+")": String(v); reqB=o; }
               else reqB='[unsupported body]'; }catch{}
        }
        try{
          const res=await origFetch.apply(this, arguments);
          const end=performance.now(); const clone=res.clone(); let resH={}, body='';
          if(CAPTURE_RES_HEADERS){ try{ resH=Object.fromEntries(clone.headers.entries()); }catch{} }
          if(CAPTURE_RES_BODY){ try{ body=kbLimit(await clone.text()); }catch{ body='[read body failed]'; } }
          post({ type:'fetch', method, url, startTime: Date.now(), duration: Math.round(end-start), status: res.status,
                 request:{ headers:reqH, body:reqB }, response:{ headers:resH, body:safeJSON(body) } });
          return res;
        }catch(err){
          post({ type:'fetch', method, url, startTime: Date.now(), duration: Math.round(performance.now()-start), status:0, error:String(err),
                 request:{ headers:reqH, body:reqB } });
          throw err;
        }
      };
      try{ Object.defineProperty(window,'fetch',{value:fetchWrap,writable:false,configurable:false}); fetchWrap.toString=()=>origFetch.toString(); }catch{ window.fetch=fetchWrap; }

      // XHR
      const XHR=XMLHttpRequest, openOrig=XHR.prototype.open, sendOrig=XHR.prototype.send;
      XHR.prototype.open=function(m,u){ this.__qtools={method:String(m||'GET').toUpperCase(), url:String(u||''), start:0}; return openOrig.apply(this, arguments); };
      XHR.prototype.send=function(body){
        const info=this.__qtools||(this.__qtools={}); info.start=performance.now();
        let reqB;
        if(CAPTURE_REQ_BODY && body!=null){
          try{ if(typeof body==='string') reqB=safeJSON(kbLimit(body));
               else if(body instanceof Blob) reqB="Blob("+(body.type||"unknown")+", "+body.size+" bytes)";
               else if(body instanceof FormData){ const o={}; for(const [k,v] of body.entries()) o[k]=(v instanceof File)? "File("+v.name+","+v.size+")": String(v); reqB=o; }
               else reqB='[unsupported body]'; }catch{}
        }
        this.addEventListener('loadend', function(){
          const end=performance.now(), status=this.status||0;
          let resH={}; if(${CAPTURE_RES_HEADERS}){ try{ const raw=this.getAllResponseHeaders(); raw.trim().split(/[\\r\\n]+/).forEach(line=>{ const i=line.indexOf(':'); if(i>0) resH[line.slice(0,i).trim().toLowerCase()]=line.slice(i+1).trim(); }); }catch{} }
          let bodyText=''; if(${CAPTURE_RES_BODY}){ try{ bodyText=(this.responseType===''||this.responseType==='text')? String(this.response||'') : ('[responseType='+this.responseType+']'); bodyText=kbLimit(bodyText); }catch{ bodyText='[read body failed]'; } }
          post({ type:'xhr', method:info.method, url:info.url, startTime: Date.now(), duration: Math.round(end-info.start), status,
                 request:{ body:reqB }, response:{ headers:resH, body:safeJSON(bodyText) } });
        });
        return sendOrig.apply(this, arguments);
      };

      // sendBeacon
      if(${CAPTURE_SEND_BEACON} && navigator.sendBeacon){
        const sbOrig=navigator.sendBeacon.bind(navigator);
        const sbWrap=function(url,data){
          let body=null; try{ if(typeof data==='string') body=kbLimit(data); else if(data instanceof Blob) body="Blob("+(data.type||"unknown")+", "+data.size+" bytes)"; else if(data) body=String(data); }catch{}
          post({ type:'beacon', method:'BEACON', url:String(url||''), startTime: Date.now(), status:0, request:{ body: body? safeJSON(body): null } });
          return sbOrig(url,data);
        };
        try{ Object.defineProperty(navigator,'sendBeacon',{value:sbWrap,writable:false,configurable:false}); }catch{ navigator.sendBeacon=sbWrap; }
      }

      // EventSource
      if(${CAPTURE_SSE} && window.EventSource){
        const ESOrig=window.EventSource;
        const ESWrap=function(url,config){
          const es=new ESOrig(url,config);
          try{ post({ type:'sse', method:'SSE', url:String(url||''), startTime: Date.now(), status:0 });
               es.addEventListener('error',()=> post({ type:'sse', method:'SSE', url:String(url||''), startTime: Date.now(), status:-1 })); }catch{}
          return es;
        };
        try{ Object.defineProperty(window,'EventSource',{value:ESWrap,writable:false,configurable:false}); }catch{ window.EventSource=ESWrap; }
      }

      // WebSocket
      if(${CAPTURE_WEBSOCKET} && window.WebSocket){
        const WSOrig=window.WebSocket;
        const WSWrap=function(url,protocols){
          const ws=new WSOrig(url,protocols); const u=String(url||''); const start=Date.now();
          try{ post({ type:'ws', method:'WS', url:u, startTime:start, status:0 });
               ws.addEventListener('close',(e)=> post({ type:'ws', method:'WS', url:u, startTime:start, status:e.code||0 })); }catch{}
          return ws;
        };
        try{ Object.defineProperty(window,'WebSocket',{value:WSWrap,writable:false,configurable:false}); }catch{ window.WebSocket=WSWrap; }
      }

      // Watchdog
      setInterval(()=>{ try{ if(window.fetch!==fetchWrap) Object.defineProperty(window,'fetch',{value:fetchWrap,writable:false,configurable:false}); }catch{ window.fetch=fetchWrap; }
                        try{ if(XMLHttpRequest.prototype.open!==XHR.prototype.open) XMLHttpRequest.prototype.open=XHR.prototype.open;
                             if(XMLHttpRequest.prototype.send!==XHR.prototype.send) XMLHttpRequest.prototype.send=XHR.prototype.send; }catch{} }, 1000);

      // Ready
      try{ window.postMessage({__QTOOLS_NET_READY__:true}, '*'); if(window.top && window.top!==window) window.top.postMessage({__QTOOLS_NET_READY__:true}, '*'); }catch{}
    })();
  `;
  const script=document.createElement('script'); script.textContent=INJECT;
  (document.documentElement||document.head||document.body).appendChild(script); script.remove();

  // ===== Êé•Êî∂ & ËøáÊª§ÂÖ•Ë°® =====
  addEventListener('message', (e) => {
    const d=e.data;
    if(d?.__QTOOLS_NET_READY__){ const st=getState(); if(st.on) console.log('[QTools] Net hook ready'); return; }
    if(!d?.__QTOOLS_NET__ || !d.entry) return;
    if(!shouldKeep(d.entry)) return;
    NETLOGS.push(d.entry); clamp();
  });

  // ===== È°∂Â±ÇÊåÇËΩΩÊåâÈíÆÔºõÊâÄÊúâ frame ÈÉΩÊ≥®ÂÖ• hook =====
  if(isTopWindow()){
    const ensure=()=>{ if(!document.getElementById(FAB_ID)) mountFabOnce(); };
    new MutationObserver(ensure).observe(document.documentElement,{childList:true,subtree:true}); ensure();
  }

  // Êö¥Èú≤Âà∞ÂÖ®Â±Ä‰æõË∞ÉËØï‰ΩøÁî®
  window.QTools = {
    getState,
    setState,
    NETLOGS,
    openCookiePanel,
    openNetPanel,
    openSettingsPanel,
    readAllVisibleCookies,
    downloadHar
  };

})();
